/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved. 
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *   
 *  The above copyright notice and this permission notice shall be included in 
 *  all copies or substantial portions of the Software.
 *   
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */

module powerbi.extensibility.utils.tooltip {
    // powerbi
    import DataViewObjectPropertyIdentifier = powerbi.DataViewObjectPropertyIdentifier;
    import DataViewValueColumn = powerbi.DataViewValueColumn;
    import DataViewMetadataColumn = powerbi.DataViewMetadataColumn;
    import DataViewCategorical = powerbi.DataViewCategorical;
    import DataViewCategoryColumn = powerbi.DataViewCategoryColumn;

    // powerbi.extensibility.utils.formatting
    import valueFormatter = powerbi.extensibility.utils.formatting.valueFormatter;

    // powerbi.extensibility.utils.tooltip
    import VisualTooltipDataItem = powerbi.extensibility.utils.tooltip.VisualTooltipDataItem;
    import TooltipSeriesDataItem = powerbi.extensibility.utils.tooltip.TooltipSeriesDataItem;
    import TooltipCategoryDataItem = powerbi.extensibility.utils.tooltip.TooltipCategoryDataItem;
    import ToolTipComponent = powerbi.extensibility.utils.tooltip.ToolTipComponent;

    export module tooltipBuilder {

        // TODO: implement options bag as input parameter
        export function createTooltipInfo(
            formatStringProp: DataViewObjectPropertyIdentifier,
            dataViewCat: DataViewCategorical,
            categoryValue: any,
            value?: any,
            categories?: DataViewCategoryColumn[],
            seriesData?: TooltipSeriesDataItem[],
            seriesIndex?: number,
            categoryIndex?: number,
            highlightedValue?: any,
            gradientValueColumn?: DataViewValueColumn): VisualTooltipDataItem[] {
            let categorySource: TooltipCategoryDataItem;
            let seriesSource: TooltipSeriesDataItem[] = [];
            let valuesSource: DataViewMetadataColumn = undefined;
            seriesIndex = seriesIndex | 0;

            let categoriesData = dataViewCat ? dataViewCat.categories : categories;
            if (categoriesData && categoriesData.length > 0) {
                if (categoriesData.length > 1) {
                    let compositeCategoriesData = [];
                    for (let i = 0, ilen = categoriesData.length; i < ilen; i++) {
                        compositeCategoriesData.push(categoriesData[i].source);
                    }
                    categorySource = { value: categoryValue, metadata: compositeCategoriesData };
                }
                else {
                    categorySource = { value: categoryValue, metadata: [categoriesData[0].source] };
                }
            }
            if (dataViewCat && dataViewCat.values) {
                if (categorySource && categorySource.metadata[0] === dataViewCat.values.source) {
                    // Category/series on the same column -- don't repeat its value in the tooltip.
                }
                else {
                    valuesSource = dataViewCat.values.source;
                }
                if (dataViewCat.values.length > 0) {
                    let valueColumn: DataViewValueColumn = dataViewCat.values[seriesIndex];
                    let isAutoGeneratedColumn: boolean = !!(valueColumn && valueColumn.source && (<any>valueColumn.source).isAutoGeneratedColumn);

                    if (!isAutoGeneratedColumn) {
                        seriesSource.push({ value: value, highlightedValue: highlightedValue, metadata: valueColumn });
                    }
                }

                // Create Gradient tooltip value
                let gradientToolTipData = createGradientToolTipData(gradientValueColumn, categoryIndex);
                if (gradientToolTipData != null)
                    seriesSource.push(gradientToolTipData);
            }
            if (seriesData) {
                for (let i: number = 0, len: number = seriesData.length; i < len; i++) {
                    let singleSeriesData: TooltipSeriesDataItem = seriesData[i];
                    if (categorySource && categorySource.metadata[0] === singleSeriesData.metadata.source)
                        continue;

                    seriesSource.push({ value: singleSeriesData.value, metadata: singleSeriesData.metadata });
                }
            }

            let tooltipInfo: VisualTooltipDataItem[] = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);

            return tooltipInfo;
        }

        export function createGradientToolTipData(gradientValueColumn: DataViewValueColumn, categoryIndex: number): TooltipSeriesDataItem {
            if (gradientValueColumn) {
                // Saturation color
                return { value: gradientValueColumn.values[categoryIndex], metadata: { source: gradientValueColumn.source, values: [] } };
            }
            return null;
        }

        function createTooltipData(
            formatStringProp: DataViewObjectPropertyIdentifier,
            categoryValue: TooltipCategoryDataItem,
            valuesSource: DataViewMetadataColumn,
            seriesValues: TooltipSeriesDataItem[]): VisualTooltipDataItem[] {

            let items: VisualTooltipDataItem[] = [];

            if (categoryValue) {
                if (categoryValue.metadata.length > 1) {
                    let displayName = "";
                    // This is being done simply for lat/long for now, as that's the only composite category we use.  If we ever have tooltips
                    //   involving other composite categories, we need to do a more thorough design and be more careful here.
                    for (let i = 0, ilen = categoryValue.metadata.length; i < ilen; i++) {
                        if (i !== 0)
                            displayName += "/";
                        displayName += categoryValue.metadata[i].displayName;
                    }
                    let categoryFormattedValue: string = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                    items.push({ displayName: displayName, value: categoryFormattedValue });
                }
                else {
                    let categoryFormattedValue: string = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                    items.push({ displayName: categoryValue.metadata[0].displayName, value: categoryFormattedValue });
                }
            }

            if (valuesSource) {
                // Dynamic series value
                let dynamicValue: string;
                if (seriesValues.length > 0) {
                    let dynamicValueMetadata: DataViewMetadataColumn = seriesValues[0].metadata.source;
                    dynamicValue = getFormattedValue(valuesSource, formatStringProp, dynamicValueMetadata.groupName);
                }
                items.push({ displayName: valuesSource.displayName, value: dynamicValue });
            }

            for (let i = 0; i < seriesValues.length; i++) {
                let seriesData = seriesValues[i];

                if (seriesData && seriesData.metadata) {
                    let seriesMetadataColumn = seriesData.metadata.source;
                    let value = seriesData.value;
                    let highlightedValue = seriesData.highlightedValue;

                    if (value || value === 0) {
                        let formattedValue: string = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
                        items.push({ displayName: seriesMetadataColumn.displayName, value: formattedValue });
                    }

                    if (highlightedValue || highlightedValue === 0) {
                        let formattedHighlightedValue: string = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue);
                        let displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                        items.push({ displayName: displayName, value: formattedHighlightedValue });
                    }
                }
            }

            return items;
        }

        function getFormattedValue(column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier, value: any) {
            let formatString: string = getFormatStringFromColumn(column, formatStringProp);
            return valueFormatter.format(value, formatString);
        }

        function getFormatStringFromColumn(column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier): string {
            if (column) {
                let formatString: string = valueFormatter.getFormatString(column, formatStringProp, true);
                return formatString || column.format;
            }
            return null;
        }
    }
}
